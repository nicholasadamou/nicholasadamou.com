---
title: "How I Developed IBM's Secrets Updater Tool and Saved Developers 99.99% of Their Time"
date: "2023-08-01"
summary: "Discover how the IBM Secrets Updater Tool drastically reduces the time and effort required to manage API credentials and tokens across multiple repositories in the CIO CI/CD pipeline."
tags: ["IBM", "Development", "CI/CD", "Secrets Management", "Automation", "Python", "Swagger"]
---

## Introduction

Managing API credentials and tokens across a large number of repositories is a challenging and time-consuming task, especially in a development ecosystem with over 60 repositories. This was the situation faced within IBM's DevEx CI/CD pipeline, where the periodic expiration of Cirrus API credentials and Artifactory ID tokens required a cumbersome, manual update process. Recognizing the inefficiency of this approach, I developed the IBM Secrets Updater Tool, an innovative solution that automates this process, reducing the update time by 99.99% and freeing developers to focus on more strategic initiatives.

## Business Opportunity

The traditional method of updating secrets involved manually re-encrypting credentials, re-scanning for secrets, and pushing updates to each repository individually. This labor-intensive process consumed significant developer time and was prone to errors, especially when dealing with numerous repositories. To streamline this process, I designed and developed the IBM Secrets Updater Tool—a solution that automates the entire update process by generating pull requests for each repository based on the provided credentials and tokens. This innovation transformed a task that could take days into one that takes seconds.

## Developer Contribution

As the lead developer, I was responsible for the end-to-end development of the Secrets Updater Tool, from concept to completion. The tool is structured into three key components: API, CLI, and Library.

### Library

The core logic of the tool is encapsulated in a reusable Python library, which serves as the backbone for both the CLI and API interfaces. This modular approach ensures that the business logic remains consistent across different interfaces and can be easily extended or modified without affecting the user-facing components.

- **Repository Management**: The library includes functions for interacting with Git repositories, including cloning, branching, committing, and pushing changes. It also manages the encryption and decryption of secrets using IBM's secure encryption algorithms.

- **Secrets Handling**: The library abstracts the complexities of managing secrets. It automates the process of fetching the latest credentials from secure storage, re-encrypting them, and updating the corresponding configuration files in each repository. This is all done in a way that ensures security and consistency across all repositories.

### CLI Tool

The CLI tool provides a command-line interface for developers who prefer to manage secrets directly from their terminal. It leverages the Python library to perform tasks like:

```python
# Example CLI command to update secrets
secrets_updater_cli.py --update-secrets --repos repo1, repo2, repo3 --token <auth_token>
```

- **Command Parsing**: The CLI uses Python’s `argparse` module to handle command-line arguments, providing a flexible and user-friendly interface for developers. The CLI also supports subcommands for different operations, such as `update-secrets`, `list-repos`, and `check-status`.

- **Error Handling**: The CLI includes robust error handling mechanisms, ensuring that any issues encountered during execution are logged and reported to the user, without crashing the tool. This includes handling edge cases like network failures, incorrect repository names, and permission issues.

### API

The API interface allows developers to interact with the tool over HTTP, providing a web-based alternative to the CLI. This API is designed using Flask, a lightweight Python web framework, and is fully documented using Swagger.

- **RESTful Endpoints**: The API exposes a set of RESTful endpoints that mirror the functionality of the CLI. Developers can trigger updates, check the status of repositories, and retrieve logs directly through HTTP requests.

- **Swagger Integration**: The API is fully documented using Swagger, which generates an interactive UI where developers can test the endpoints directly from their browser. This not only makes the API more accessible but also simplifies integration with other tools and services.

```yaml
# Example Swagger API definition for updating secrets
paths:
  /update-secrets:
    post:
      summary: Update secrets across multiple repositories
      parameters:
        - name: repos
          in: query
          required: true
          type: string
          description: "Comma-separated list of repositories"
        - name: token
          in: header
          required: true
          type: string
          description: "Authentication token"
      responses:
        '200':
          description: Success
        '400':
          description: Bad request
        '401':
          description: Unauthorized
        '500':
          description: Internal server error
```

## Technical Details

### Levenshtein Distance Algorithm

To enhance the robustness of the tool, I implemented the Levenshtein Distance algorithm in the `create_branch_for_repo` function. This algorithm helps the tool handle minor errors in repository naming by calculating the similarity between the provided repository name and the actual names in the system. Here's how it works:

1. **Fetching Repositories**: The tool first attempts to fetch the repository directly using the provided `repo_name`. If this fails due to a misspelling or other error, the tool moves on to the next step.

2. **Finding a Close Match**: The tool retrieves a list of all repositories and compares the provided `repo_name` with each repository's name using the Levenshtein Distance algorithm.

3. **Calculating Similarity**: The algorithm calculates the minimum number of single-character edits (insertions, deletions, substitutions) required to transform one string into another. A lower distance indicates a closer match.

4. **Selecting the Closest Match**: If a repository with a sufficiently low Levenshtein distance is found, the tool assumes this to be the intended repository and proceeds with the update.

5. **Creating a Branch**: Once the correct repository is identified, the tool creates a new branch, updates the secrets, and commits the changes.

This feature is especially useful in automated environments where human errors in naming can occur. It significantly reduces the likelihood of failures due to simple typos, ensuring that the tool can operate smoothly across many repositories.

### Multi-threading with Thread Pool

The Secrets Updater Tool leverages Python's `ThreadPool` from the `multiprocessing.pool` module to manage concurrent tasks. This multi-threaded approach is critical for scaling the tool to handle updates across dozens of repositories simultaneously.

- **Optimal Resource Utilization**: The number of threads in the pool is determined by the machine's CPU count, minus one, ensuring that system resources are used efficiently without overloading the CPU.

- **Asynchronous Execution**: Tasks, such as updating secrets in a repository, are submitted to the thread pool using the `apply_async` method. This allows the tool to initiate multiple updates in parallel, dramatically reducing the overall execution time.

- **Non-Blocking Operations**: While the threads are working, the main program can continue executing other operations, such as monitoring task completion or submitting additional tasks. This non-blocking behavior contributes to the tool's overall efficiency.

- **Error Isolation**: Each task runs independently, meaning that an error in one task does not affect others. This isolation increases the robustness of the tool, ensuring that it can continue operating even if a particular repository update fails.

This approach to multi-threading not only enhances the performance of the Secrets Updater Tool but also ensures that it can scale to meet the demands of large enterprise environments with numerous repositories.

### Swagger Documentation

As the lead developer, I integrated Swagger for API documentation, ensuring that the API is well-documented, easy to understand, and straightforward to use. Swagger's benefits include:

- **Interactive Documentation**: Developers can interact with the API directly through the Swagger UI, making it easier to test endpoints and understand how the API works.

- **Standardization**: Swagger enforces a standardized format for documenting API endpoints, methods, parameters, and responses. This consistency improves collaboration between front-end and back-end teams and reduces ambiguities.

- **Design-First Approach**: Swagger encourages a design-first approach, where the API is planned and documented before implementation. This leads to more thoughtful and consistent API designs, reducing the likelihood of issues during development.

The adoption of Swagger has significantly improved the developer experience, making the API more accessible and easier to integrate with other tools and services.

## Impact

The IBM Secrets Updater Tool has had a profound impact on the productivity of development teams within IBM. In a case study, teams managing 12 to 60+ repositories saw a 99.99% reduction in the time required to update their secrets. This not only freed up significant developer time but also reduced the potential for errors in the process.

To build awareness and drive adoption of the tool, I engaged in extensive outreach. I submitted an issue on the official CIO CI/CD pipeline repository, spoke about the tool in the Developer Experience and DevSecOps Open Guild Meeting, and published a blog post highlighting the tool's benefits. The feedback from these efforts was overwhelmingly positive, with recognition from key figures.

## Lessons Learned

### Early Adoption of Robust Algorithms

Implementing the Levenshtein Distance algorithm early in the development process proved invaluable. It allowed the tool to handle minor errors in repository naming without manual intervention, enhancing its reliability and usability. This experience underscored the importance of building robust error-handling mechanisms into tools that operate at scale.

### The Power of Multi-threading

Utilizing a ThreadPool to manage concurrent tasks brought significant performance improvements. This approach allowed the tool to process updates across multiple

 repositories simultaneously, reducing overall execution time and improving efficiency. The isolation provided by the ThreadPool also ensured that errors in one task did not affect others, contributing to the tool's robustness.

### The Value of Swagger Documentation

Adopting Swagger for API documentation was a game-changer. It streamlined the API lifecycle, from design and documentation to testing and maintenance. The interactive Swagger UI made it easy for developers to test and integrate the API, fostering greater collaboration and speeding up the development process. This experience highlighted the importance of clear, standardized documentation in enhancing the developer experience.

## Conclusion

The IBM Secrets Updater Tool represents a significant step forward in automating and streamlining the management of API credentials and tokens across multiple repositories. By reducing the time required for these updates by 99.99%, the tool has freed developers to focus on more strategic initiatives, driving productivity and innovation.

The technical innovations, including the use of the Levenshtein Distance algorithm, multi-threading, and Swagger documentation, have made the tool robust, scalable, and easy to use. The positive feedback and recognition from the developer community further underscore its impact.

Looking ahead, I am excited to see how this tool will continue to evolve and support IBM's development teams, enabling them to work more efficiently and effectively in an increasingly complex and demanding environment.
